#--- Stats/Profiling output ---------------------------------------------------

logging        = true                      # Toggle logging output
console        = true                      # Toggle if logging out goes to console or log file
log_file       = log.txt                   # Name of log file
output_path    = ./output                  # File path for demo/application output

verbose        = true                      # Toggle verbose output
profiling      = true                      # Toggle profiling
silent_threads = false                     # true for no console output for threads, false for debugging in single-threaded case (number_of_subdomains = 1)

#--- Input Data (test scene) -------------------------------------------------

#txt_filename = horseshoe.txt
#txt_filename = magnet.txt
txt_filename = two_bars_example.txt

no_ears                    = true         # Toogle if ears are allowed or not in the input mesh
use_manifold               = true         # Toggle if input mesh should be manifold or not
use_simple_boundary        = true        # Toggle if input mesh is allowed to have holes
no_multiple_vertices       = false        # Toggle if input mesh is allowed to have multiple vertices with similar coordinates
multiple_vertices_threshold = 0.001       # Accuracy to test for multiple vertides

input_labels   = 0 1 2                    # Number of labels to consider in the input mesh (there could be more in the input data, but they are do not cares)
labels         = 0 1 2                    # Number of elements same as input_labels, sequence maps to same sequence in input_labels
use_ambient    = false                    # Could be false, ambient phase can't have any attributes associated with it
ambient_label  = 0                        # Must be a grit_label
magnet_label   = 1                        # The label that corresponds to solid walls
magnet_labels  = 1 2

#--- Simulation Loop Control ------------------------------------------------
frames      = 2                           # Number of frames (simulation steps) to take in fixed loop
skip_frames = 1                           # Number of inbetween frames to skip when rendering frames, only used for fixed loop

#--- Model parameters --------------------------------------------------------
mx           = 1                         # x-component of magnetic field
my           = 0                         # y-component of magnetic field
mxs          = 0 0
mys          = 1 -1
# Syntax:
# dipole_field = constant label mx my
#         label is the label in the mesh this dipole field is applied to
#         mx is the x-component of the magnetisation
#         my is the y-component
#   or
# dipole_field = circular label mx my cx cy
#   where
#         label is the label in the mesh this dipole field is applied to
#         mx and
#         my is the magnetisation in the point (1,0) on a unit circle
#         cx and
#         cy is the center of the circular dipole field
dipole_fields = dipole1 dipole2 dipole3
dipole1 = constant 1 0 1
dipole2 = constant 2 0 -1
dipole3 = circular 3 -1 0 0 0

#--- Simulation Toggles -----------------------------------------------------
order_2nd    = true                     # Boolean flag for controlling whether we use 2nd order Neumann BC or 1st order

#--- Solver Numerical parameters ----------------------------------------------------
solver_use_host           = true
solver_max_iterations     = 400
solver_relative_tolerance = 1e-15         # Default value was 0.001
solver_absolute_tolerance = 1e-10         # Default value was 0.0001

# Diagonal preconditioner seems superior to everything else. Solver choice insignificant.
# Identity and PCG for pressure systems, set absolute tolerance low.

# BiCG + Bridson work well when 2nd order BC is turned off
#solver_choice         = 2           # 0: PCG, 1: CR, 2: BiCG, 3: BiCGStab, 4: GMRES
#preconditioner_choice = 2           # 0: diagonal, 1: identity (no preconditioner), 2: Bridson_Ainv

# BiCGStab + no preconditioner work well using 2nd order BC (GMRES work too, but can not get as good accuracy)....
solver_choice         = 3           # 0: PCG, 1: CR, 2: BiCG, 3: BiCGStab, 4: GMRES
preconditioner_choice = 1           # 0: diagonal, 1: identity (no preconditioner), 2: Bridson_Ainv


#--- Stats/Profiling output ---------------------------------------------------
matlab_write    = true                   # If true then write simulation data to matlab script(s)
matlab_append   = false                  # If false then data for each time-step is written
                                         # to individual matlab script files. If true all
                                         # data are written to one matlab script file
matlab_filename = magnostatic.m               # Name of matlab script file to write data into

#--- Engine control ------------------------------------------------------

number_of_subdomains      = 1               # Number of subdomains (threads)
make_unit                 = true            # Toggle to scale the domain to unit square
scheduler.max_iterations  = 4               # Maximum number of scheduler iterations per time-step
algorithm.max_iterations  = 10              # Maximum number of algorithm iterations (to prevent infinite loops)
use_only_interface        = false           # If true, only interface is affected

#
# syntax operations = [vertex split] [move] [merge] [coarsening] [interface_coarsening] [refinement] [interface_refinement] [smoothing] [interface_smoothing] [optimization]
#
# This statement is essentially a white space separated list of named operations the engine performs
# when updating the mesh in-between simulation steps. If a named operation is omitted then the
# engine will not perform that operation.
#
operations = vertex_split move merge coarsening interface_coarsening refinement interface_refinement smoothing interface_smoothing optimization ear_removal

#
# Here we import specific settings into named scopes.
#
# Import syntax: import [scope_name]  =  cfg-file
#
# The "import" terminal is a keyword that tells the cfg-parser to start reading
# in a another cfg-file. This is convenient to have hierarchical
# cfg-files to better logical collect similar settings in a
# logical meaningful way.
#
# The optional field scope_name when specified will create a new named scope to store the
# cfg-file into. The value of  "scope_name" identifies the internal name
# in the cfg-parser stores the imported settings under. The name only has meaning
# to manipulate settings in the actual cfg-files
#
#  If the scope_name is omitted then the import is done into the current scope. Redundant
#  settings in same scope do not overwrite previous settings, but rather creates
#  a list instead.
#
#    myvar = one
#    myvar = two
#
#  Behaves like
#
#    myvar = one two
#
#
import params_vertex_split         = remeshing_params/vertex_split.cfg
import params_move                 = remeshing_params/move.cfg
import params_merge                = remeshing_params/merge.cfg
import params_coarsening           = remeshing_params/coarsening.cfg
import params_interface_coarsening = remeshing_params/interface_coarsening.cfg
import params_refinement           = remeshing_params/refinement.cfg
import params_interface_refinement = remeshing_params/interface_refinement.cfg
import params_smoothing            = remeshing_params/smoothing.cfg        # Laplacian smoothing of non-interface vertices
import params_interface_smoothing  = remeshing_params/interface_smoothing.cfg
import params_optimization         = remeshing_params/optimization.cfg     # edge flip optimization

#
# syntax: assign = operation_name label_value scope_name;
#
# This statement assigns cfg settings for a specific operation and phase. This
# is for instance convenient if settings varies in different phases. Like
# having a coarse mesh in ambient phase but fine meshes elsewhere.
#
# The field operation name must be among the names given in the
# operations statement. The field scope_name must correspond to a
# scope created by a import statement.
#
assign = vertex_split         0 params_vertex_split
assign = vertex_split         1 params_vertex_split

assign = move                 1 params_move

assign = merge                0 params_merge
assign = merge                1 params_merge

assign = coarsening           0 params_coarsening
assign = coarsening           1 params_coarsening

assign = interface_coarsening 0 params_interface_coarsening
assign = interface_coarsening 1 params_interface_coarsening

assign = refinement           0 params_refinement
assign = refinement           1 params_refinement

assign = interface_refinement 0 params_interface_refinement
assign = interface_refinement 1 params_interface_refinement

assign = smoothing            0 params_smoothing
assign = smoothing            1 params_smoothing

assign = interface_smoothing  0 params_interface_smoothing
assign = interface_smoothing  1 params_interface_smoothing

assign = optimization         0 params_optimization
assign = optimization         1 params_optimization

#
# syntax: override = operation_name label_value parameter_name parameter_value
#
# The override statement is convenient when re-using cfg file scopes. Say
# that for a particular application one only wishes to change one parameter
# for one operation in a particular phase...but re-use the same settings
# everywhere else. The override statement allows one to specify what parameters
# should be changed.
#
#

override = ear_removal          0 max_iterations   1
override = ear_removal          1 max_iterations   1

override = interface_refinement 0 max_iterations 0        # Turn off interface refinement for ambient space
override = interface_refinement 1 max_iterations 2
override = interface_refinement 1 lower_threshold  0.03

override = coarsening           0 upper_threshold  0.04

override = coarsening           1 upper_threshold  0.025
override = coarsening           1 max_iterations  2

override = refinement           1 max_iterations 2

override = smoothing            0 max_iterations 5
override = smoothing            1 max_iterations 5




